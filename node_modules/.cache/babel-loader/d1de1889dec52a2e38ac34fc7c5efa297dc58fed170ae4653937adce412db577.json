{"ast":null,"code":"function t() {\n  return t = Object.assign ? Object.assign.bind() : function (t) {\n    for (var i = 1; i < arguments.length; i++) {\n      var e = arguments[i];\n      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, t.apply(this, arguments);\n}\nfunction i(t, i, e) {\n  return Math.max(t, Math.min(i, e));\n}\nclass e {\n  advance(t) {\n    var e;\n    if (!this.isRunning) return;\n    let s = !1;\n    if (this.lerp) this.value = (o = this.value, n = this.to, (1 - (r = 1 - Math.exp(-60 * this.lerp * t))) * o + r * n), Math.round(this.value) === this.to && (this.value = this.to, s = !0);else {\n      this.currentTime += t;\n      const e = i(0, this.currentTime / this.duration, 1);\n      s = e >= 1;\n      const o = s ? 1 : this.easing(e);\n      this.value = this.from + (this.to - this.from) * o;\n    }\n    var o, n, r;\n    null == (e = this.onUpdate) || e.call(this, this.value, {\n      completed: s\n    }), s && this.stop();\n  }\n  stop() {\n    this.isRunning = !1;\n  }\n  fromTo(t, i, {\n    lerp: e = .1,\n    duration: s = 1,\n    easing: o = t => t,\n    onUpdate: n\n  }) {\n    this.from = this.value = t, this.to = i, this.lerp = e, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, this.onUpdate = n;\n  }\n}\nclass s {\n  constructor({\n    wrapper: t,\n    content: i,\n    autoResize: e = !0\n  } = {}) {\n    if (this.resize = () => {\n      this.onWrapperResize(), this.onContentResize();\n    }, this.onWrapperResize = () => {\n      this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);\n    }, this.onContentResize = () => {\n      this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;\n    }, this.wrapper = t, this.content = i, e) {\n      const t = function (t, i) {\n        let e;\n        return function () {\n          let i = arguments,\n            s = this;\n          clearTimeout(e), e = setTimeout(function () {\n            t.apply(s, i);\n          }, 250);\n        };\n      }(this.resize);\n      this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t), this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var t, i;\n    null == (t = this.wrapperResizeObserver) || t.disconnect(), null == (i = this.contentResizeObserver) || i.disconnect();\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n}\nclass o {\n  constructor() {\n    this.events = {};\n  }\n  emit(t, ...i) {\n    let e = this.events[t] || [];\n    for (let t = 0, s = e.length; t < s; t++) e[t](...i);\n  }\n  on(t, i) {\n    var e;\n    return (null == (e = this.events[t]) ? void 0 : e.push(i)) || (this.events[t] = [i]), () => {\n      var e;\n      this.events[t] = null == (e = this.events[t]) ? void 0 : e.filter(t => i !== t);\n    };\n  }\n  destroy() {\n    this.events = {};\n  }\n}\nclass n {\n  constructor(t, {\n    wheelMultiplier: e = 1,\n    touchMultiplier: s = 2,\n    normalizeWheel: n = !1\n  }) {\n    this.onTouchStart = t => {\n      const {\n        clientX: i,\n        clientY: e\n      } = t.targetTouches ? t.targetTouches[0] : t;\n      this.touchStart.x = i, this.touchStart.y = e, this.lastDelta = {\n        x: 0,\n        y: 0\n      };\n    }, this.onTouchMove = t => {\n      const {\n          clientX: i,\n          clientY: e\n        } = t.targetTouches ? t.targetTouches[0] : t,\n        s = -(i - this.touchStart.x) * this.touchMultiplier,\n        o = -(e - this.touchStart.y) * this.touchMultiplier;\n      this.touchStart.x = i, this.touchStart.y = e, this.lastDelta = {\n        x: s,\n        y: o\n      }, this.emitter.emit(\"scroll\", {\n        type: \"touch\",\n        deltaX: s,\n        deltaY: o,\n        event: t\n      });\n    }, this.onTouchEnd = t => {\n      this.emitter.emit(\"scroll\", {\n        type: \"touch\",\n        inertia: !0,\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event: t\n      });\n    }, this.onWheel = t => {\n      let {\n        deltaX: e,\n        deltaY: s\n      } = t;\n      this.normalizeWheel && (e = i(-100, e, 100), s = i(-100, s, 100)), e *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit(\"scroll\", {\n        type: \"wheel\",\n        deltaX: e,\n        deltaY: s,\n        event: t\n      });\n    }, this.element = t, this.wheelMultiplier = e, this.touchMultiplier = s, this.normalizeWheel = n, this.touchStart = {\n      x: null,\n      y: null\n    }, this.emitter = new o(), this.element.addEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.addEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.addEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.addEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  on(t, i) {\n    return this.emitter.on(t, i);\n  }\n  destroy() {\n    this.emitter.destroy(), this.element.removeEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n}\nclass r {\n  constructor({\n    wrapper: i = window,\n    content: r = document.documentElement,\n    wheelEventsTarget: l = i,\n    smoothWheel: h = !0,\n    smoothTouch: a = !1,\n    syncTouch: c = !1,\n    syncTouchLerp: u = .1,\n    __iosNoInertiaSyncTouchLerp: p = .4,\n    touchInertiaMultiplier: m = 35,\n    duration: d,\n    easing: v = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: g = d && .1,\n    infinite: S = !1,\n    orientation: w = \"vertical\",\n    gestureOrientation: f = \"vertical\",\n    touchMultiplier: y = 1,\n    wheelMultiplier: T = 1,\n    normalizeWheel: z = !1,\n    autoResize: M = !0\n  } = {}) {\n    this.onVirtualScroll = ({\n      type: i,\n      inertia: e,\n      deltaX: s,\n      deltaY: o,\n      event: n\n    }) => {\n      if (n.ctrlKey) return;\n      const r = \"touch\" === i,\n        l = \"wheel\" === i;\n      if (\"vertical\" === this.options.gestureOrientation && 0 === o || \"horizontal\" === this.options.gestureOrientation && 0 === s || r && \"vertical\" === this.options.gestureOrientation && 0 === this.scroll && !this.options.infinite && o <= 0) return;\n      if (n.composedPath().find(t => (null == t || null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent\")) || r && (null == t || null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-touch\")) || l && (null == t || null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-wheel\")))) return;\n      if (this.isStopped || this.isLocked) return void n.preventDefault();\n      if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && r || this.options.smoothWheel && l, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();\n      n.preventDefault();\n      let h = o;\n      \"both\" === this.options.gestureOrientation ? h = Math.abs(o) > Math.abs(s) ? o : s : \"horizontal\" === this.options.gestureOrientation && (h = s);\n      const a = r && this.options.syncTouch,\n        c = r && e && Math.abs(h) > 1;\n      c && (h = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + h, t({\n        programmatic: !1\n      }, a && {\n        lerp: c ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp\n      }));\n    }, this.onScroll = () => {\n      if (!this.isScrolling) {\n        const t = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit();\n      }\n    }, window.lenisVersion = \"1.0.19\", i !== document.documentElement && i !== document.body || (i = window), this.options = {\n      wrapper: i,\n      content: r,\n      wheelEventsTarget: l,\n      smoothWheel: h,\n      smoothTouch: a,\n      syncTouch: c,\n      syncTouchLerp: u,\n      __iosNoInertiaSyncTouchLerp: p,\n      touchInertiaMultiplier: m,\n      duration: d,\n      easing: v,\n      lerp: g,\n      infinite: S,\n      gestureOrientation: f,\n      orientation: w,\n      touchMultiplier: y,\n      wheelMultiplier: T,\n      normalizeWheel: z,\n      autoResize: M\n    }, this.dimensions = new s({\n      wrapper: i,\n      content: r,\n      autoResize: M\n    }), this.rootElement.classList.add(\"lenis\"), this.velocity = 0, this.isStopped = !1, this.isSmooth = h || a, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.animate = new e(), this.emitter = new o(), this.options.wrapper.addEventListener(\"scroll\", this.onScroll, {\n      passive: !1\n    }), this.virtualScroll = new n(l, {\n      touchMultiplier: y,\n      wheelMultiplier: T,\n      normalizeWheel: z\n    }), this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n  }\n  destroy() {\n    this.emitter.destroy(), this.options.wrapper.removeEventListener(\"scroll\", this.onScroll, {\n      passive: !1\n    }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.rootElement.classList.remove(\"lenis\"), this.rootElement.classList.remove(\"lenis-smooth\"), this.rootElement.classList.remove(\"lenis-scrolling\"), this.rootElement.classList.remove(\"lenis-stopped\");\n  }\n  on(t, i) {\n    return this.emitter.on(t, i);\n  }\n  off(t, i) {\n    var e;\n    this.emitter.events[t] = null == (e = this.emitter.events[t]) ? void 0 : e.filter(t => i !== t);\n  }\n  setScroll(t) {\n    this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t;\n  }\n  resize() {\n    this.dimensions.resize();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = !1, this.isScrolling = !1, this.velocity = 0, this.animate.stop();\n  }\n  start() {\n    this.isStopped = !1, this.reset();\n  }\n  stop() {\n    this.isStopped = !0, this.animate.stop(), this.reset();\n  }\n  raf(t) {\n    const i = t - (this.time || t);\n    this.time = t, this.animate.advance(.001 * i);\n  }\n  scrollTo(t, {\n    offset: e = 0,\n    immediate: s = !1,\n    lock: o = !1,\n    duration: n = this.options.duration,\n    easing: r = this.options.easing,\n    lerp: l = !n && this.options.lerp,\n    onComplete: h = null,\n    force: a = !1,\n    programmatic: c = !0\n  } = {}) {\n    if (!this.isStopped || a) {\n      if ([\"top\", \"left\", \"start\"].includes(t)) t = 0;else if ([\"bottom\", \"right\", \"end\"].includes(t)) t = this.limit;else {\n        var u;\n        let i;\n        if (\"string\" == typeof t ? i = document.querySelector(t) : null != (u = t) && u.nodeType && (i = t), i) {\n          if (this.options.wrapper !== window) {\n            const t = this.options.wrapper.getBoundingClientRect();\n            e -= this.isHorizontal ? t.left : t.top;\n          }\n          const s = i.getBoundingClientRect();\n          t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;\n        }\n      }\n      if (\"number\" == typeof t) {\n        if (t += e, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = i(0, t, this.limit), s) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), this.emit(), void (null == h || h());\n        if (!c) {\n          if (t === this.targetScroll) return;\n          this.targetScroll = t;\n        }\n        this.animate.fromTo(this.animatedScroll, t, {\n          duration: n,\n          easing: r,\n          lerp: l,\n          onUpdate: (t, {\n            completed: i\n          }) => {\n            o && (this.isLocked = !0), this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), i && (o && (this.isLocked = !1), requestAnimationFrame(() => {\n              this.isScrolling = !1;\n            }), this.velocity = 0, null == h || h()), this.emit();\n          }\n        });\n      }\n    }\n  }\n  get rootElement() {\n    return this.options.wrapper === window ? this.options.content : this.options.wrapper;\n  }\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n  }\n  get isHorizontal() {\n    return \"horizontal\" === this.options.orientation;\n  }\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  get scroll() {\n    return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;\n    var t;\n  }\n  get progress() {\n    return 0 === this.limit ? 1 : this.scroll / this.limit;\n  }\n  get isSmooth() {\n    return this.__isSmooth;\n  }\n  set isSmooth(t) {\n    this.__isSmooth !== t && (this.rootElement.classList.toggle(\"lenis-smooth\", t), this.__isSmooth = t);\n  }\n  get isScrolling() {\n    return this.__isScrolling;\n  }\n  set isScrolling(t) {\n    this.__isScrolling !== t && (this.rootElement.classList.toggle(\"lenis-scrolling\", t), this.__isScrolling = t);\n  }\n  get isStopped() {\n    return this.__isStopped;\n  }\n  set isStopped(t) {\n    this.__isStopped !== t && (this.rootElement.classList.toggle(\"lenis-stopped\", t), this.__isStopped = t);\n  }\n}\nexport { r as default };","map":{"version":3,"names":["i","t","e","Math","max","min","advance","isRunning","s","lerp","value","o","n","to","r","exp","round","currentTime","duration","easing","from","onUpdate","call","completed","stop","fromTo","constructor","wrapper","content","autoResize","resize","onWrapperResize","onContentResize","window","width","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","arguments","clearTimeout","setTimeout","apply","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","limit","x","y","events","emit","length","on","push","filter","wheelMultiplier","touchMultiplier","normalizeWheel","onTouchStart","clientX","clientY","targetTouches","touchStart","lastDelta","onTouchMove","emitter","type","deltaX","deltaY","event","onTouchEnd","inertia","onWheel","element","addEventListener","passive","removeEventListener","document","documentElement","wheelEventsTarget","l","smoothWheel","h","smoothTouch","a","syncTouch","c","syncTouchLerp","u","__iosNoInertiaSyncTouchLerp","p","touchInertiaMultiplier","m","d","v","pow","g","infinite","S","orientation","w","gestureOrientation","f","T","z","M","onVirtualScroll","ctrlKey","options","scroll","composedPath","find","hasAttribute","isStopped","isLocked","preventDefault","isSmooth","isScrolling","animate","abs","velocity","scrollTo","targetScroll","programmatic","onScroll","animatedScroll","actualScroll","direction","sign","lenisVersion","body","dimensions","rootElement","classList","add","virtualScroll","remove","off","setScroll","isHorizontal","scrollLeft","scrollTop","reset","start","raf","time","offset","immediate","lock","onComplete","force","includes","querySelector","nodeType","getBoundingClientRect","left","top","requestAnimationFrame","progress","__isSmooth","toggle","__isScrolling","__isStopped","default"],"sources":["/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/maths.js","/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/animate.js","/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/dimensions.js","/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/debounce.js","/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/emitter.js","/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/virtual-scroll.js","/Users/hee/Desktop/intro_react_p/node_modules/@studio-freight/lenis/src/index.js"],"sourcesContent":["// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, { completed })\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(from, to, { lerp = 0.1, duration = 1, easing = (t) => t, onUpdate }) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\nexport class Dimensions {\r\n  constructor({ wrapper, content, autoResize = true } = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      const resize = debounce(this.resize, 250)\r\n\r\n      if (this.wrapper !== window) {\r\n        this.wrapperResizeObserver = new ResizeObserver(resize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(resize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    this.scrollHeight = this.content.scrollHeight\r\n    this.scrollWidth = this.content.scrollWidth\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","export class Emitter {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event, ...args) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event, cb) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport { clamp } from './maths'\r\n\r\nexport class VirtualScroll {\r\n  constructor(\r\n    element,\r\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\r\n  ) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n    this.normalizeWheel = normalizeWheel\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\r\n    this.element.addEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      type: 'touch',\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event) => {\r\n    this.emitter.emit('scroll', {\r\n      type: 'touch',\r\n      inertia: true,\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event) => {\r\n    let { deltaX, deltaY } = event\r\n\r\n    if (this.normalizeWheel) {\r\n      deltaX = clamp(-100, deltaX, 100)\r\n      deltaY = clamp(-100, deltaY, 100)\r\n    }\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { type: 'wheel', deltaX, deltaY, event })\r\n  }\r\n}\r\n","import { version } from '../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explaination\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\nexport default class Lenis {\r\n  // isScrolling = true when scroll is animating\r\n  // isStopped = true if user should not be able to scroll - enable/disable programatically\r\n  // isSmooth = true if scroll should be animated\r\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\r\n\r\n  /**\r\n   * @typedef {(t: number) => number} EasingFunction\r\n   * @typedef {'vertical' | 'horizontal'} Orientation\r\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\r\n   *\r\n   * @typedef LenisOptions\r\n   * @property {Window | HTMLElement} [wrapper]\r\n   * @property {HTMLElement} [content]\r\n   * @property {Window | HTMLElement} [wheelEventsTarget]\r\n   * @property {boolean} [smoothWheel]\r\n   * @property {boolean} [smoothTouch]\r\n   * @property {boolean} [syncTouch]\r\n   * @property {number} [syncTouchLerp]\r\n   * @property {number} [touchInertiaMultiplier]\r\n   * @property {number} [duration]\r\n   * @property {EasingFunction} [easing]\r\n   * @property {number} [lerp]\r\n   * @property {boolean} [infinite]\r\n   * @property {Orientation} [orientation]\r\n   * @property {GestureOrientation} [gestureOrientation]\r\n   * @property {number} [touchMultiplier]\r\n   * @property {number} [wheelMultiplier]\r\n   * @property {boolean} [normalizeWheel]\r\n   * @property {boolean} [autoResize]\r\n   *\r\n   * @param {LenisOptions}\r\n   */\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper,\r\n    smoothWheel = true,\r\n    smoothTouch = false,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.1,\r\n    __iosNoInertiaSyncTouchLerp = 0.4, // should be 1 but had to leave 0.4 for iOS (testing purpose)\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = duration && 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    normalizeWheel = false,\r\n    autoResize = true,\r\n  } = {}) {\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (wrapper === document.documentElement || wrapper === document.body) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      smoothWheel,\r\n      smoothTouch,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      __iosNoInertiaSyncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n      autoResize,\r\n    }\r\n\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    this.rootElement.classList.add('lenis')\r\n\r\n    this.velocity = 0\r\n    this.isStopped = false\r\n    this.isSmooth = smoothWheel || smoothTouch\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll = new VirtualScroll(wheelEventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener('scroll', this.onScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.rootElement.classList.remove('lenis')\r\n    this.rootElement.classList.remove('lenis-smooth')\r\n    this.rootElement.classList.remove('lenis-scrolling')\r\n    this.rootElement.classList.remove('lenis-stopped')\r\n  }\r\n\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event, callback) {\r\n    this.emitter.events[event] = this.emitter.events[event]?.filter(\r\n      (i) => callback !== i\r\n    )\r\n  }\r\n\r\n  setScroll(scroll) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  onVirtualScroll = ({ type, inertia, deltaX, deltaY, event }) => {\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = type === 'touch'\r\n    const isWheel = type === 'wheel'\r\n\r\n    if (\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) || // trackpad previous/next page gesture\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0) ||\r\n      (isTouch &&\r\n        this.options.gestureOrientation === 'vertical' &&\r\n        this.scroll === 0 &&\r\n        !this.options.infinite &&\r\n        deltaY <= 0) // touch pull to refresh\r\n    )\r\n      return\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    if (\r\n      !!event\r\n        .composedPath()\r\n        .find(\r\n          (node) =>\r\n            node?.hasAttribute?.('data-lenis-prevent') ||\r\n            (isTouch && node?.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n            (isWheel && node?.hasAttribute?.('data-lenis-prevent-wheel'))\r\n        )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault()\r\n      return\r\n    }\r\n\r\n    this.isSmooth =\r\n      ((this.options.smoothTouch || this.options.syncTouch) && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!this.isSmooth) {\r\n      this.isScrolling = false\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const hasTouchInertia = isTouch && inertia && Math.abs(delta) > 1\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch && {\r\n        lerp: hasTouchInertia\r\n          ? this.syncTouchLerp\r\n          : this.options.__iosNoInertiaSyncTouchLerp,\r\n      }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  onScroll = () => {\r\n    if (!this.isScrolling) {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.velocity = 0\r\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\r\n      this.emit()\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = !duration && this.options.lerp,\r\n      onComplete = null,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n    } = {}\r\n  ) {\r\n    if (this.isStopped && !force) return\r\n\r\n    // keywords\r\n    if (['top', 'left', 'start'].includes(target)) {\r\n      target = 0\r\n    } else if (['bottom', 'right', 'end'].includes(target)) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      this.emit()\r\n      onComplete?.()\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      if (target === this.targetScroll) return\r\n\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onUpdate: (value, { completed }) => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = true\r\n\r\n        // updated\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity)\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        // completed\r\n        if (completed) {\r\n          if (lock) this.isLocked = false\r\n          requestAnimationFrame(() => {\r\n            //avoid double scroll event\r\n            this.isScrolling = false\r\n          })\r\n          this.velocity = 0\r\n          onComplete?.()\r\n        }\r\n\r\n        this.emit()\r\n      },\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return this.options.wrapper === window\r\n      ? this.options.content\r\n      : this.options.wrapper\r\n  }\r\n\r\n  get limit() {\r\n    return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll() {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll() {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress() {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.__isSmooth\r\n  }\r\n\r\n  set isSmooth(value) {\r\n    if (this.__isSmooth !== value) {\r\n      this.rootElement.classList.toggle('lenis-smooth', value)\r\n      this.__isSmooth = value\r\n    }\r\n  }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  set isScrolling(value) {\r\n    if (this.__isScrolling !== value) {\r\n      this.rootElement.classList.toggle('lenis-scrolling', value)\r\n      this.__isScrolling = value\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  set isStopped(value) {\r\n    if (this.__isStopped !== value) {\r\n      this.rootElement.classList.toggle('lenis-stopped', value)\r\n      this.__isStopped = value\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}